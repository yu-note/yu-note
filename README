

                                  狼 行 天 下
                                      自由  协作  创造

1.

Ctrl+shift + t  加标签
Ctrl  PgDn /PgUp   换标签
不能在两个标签下打开同一文件

2.
  视频教学
          http://media.happypeter.org/screencasts.html

  

3.

+## 可视行(visual line)
+
+启动和退出: V ((Esc)shift+v)
             j k 上下选中
             d   剪切
             p(小)   往下粘贴
             P       往上粘贴
             y   复制 
+整体缩进几行代码： shift+v (可视行模式)
                    shift+v用j 或 k

+首先用可视行模式选中这几行,然后 `shift + >`,'shift + <'
 

vim a.c b.c (同时打开两个文件)
+    :ls #see buffers
+    :bn # go to next buffer
+    :bp # go to previous buffer   / （先按Esc ,shift + :）
+    :bd # 关闭 a buffer
+    :set hidden 可以不保存切换 
vim a.c
+    :e b.c # 就切过去了

vim 

+    :set number #显示行
+    :set nonumber #不显示行
                       git

+    mkdir hhh
+    git init
+    ls  # 无
+    ls -a   # . .. .git 
+    touch hello  # hello 在hhh里
+    git add hello
+    git commit -a -m "first versiom"  #第一个版本
+    tig

                       7 20
1.  git pull  # 刷新
2.  cd # 要切回上一目录在切到下面所包含目录
3.  git clone 地址
4.  file # 查看属性。
5.  ：q！ # 强行退出
6.  history # 历史操作
7.  unzip   # 解压
8.  :wq
9.  :wqa
                       ref
                      
+    http://happypeter.github.com/LGCB/
+    http://billie66.github.com/TLCL/book/

                       tar
+    http://www.happypeter.org/posts/10

                      translation
+    http://dict.youdao.com/

                      github

+    http://www.happypeter.org/posts/21
                      tar

+    http://www.happypeter.org/posts/10


  关于压缩和解压，以下几种情况最常见:

1.将名为dir的文件夹压缩为 .tar.gz的包：

   tar zcvf  dir.tar.gz dir

   相应的解压命令：

   tar zxvf dir.tar.gz
2.将名为dir的文件夹压缩为 .tar.bz2的包：

    tar jcvf dir.tar.bz2 dir

    相应的解压命令：

    tar jxvf dir.tar.bz2

    当然以上过程也个以用tar, bunzip2, gunzip, 分别分为多步完成，但是>一般不用，太麻烦，所以也不用记。以上的压缩方式，实际中只需记住一种>就够用了，但是解压方式两种都要死记硬背下来，因为太常用了。



                     获取key
+   cd
+   ssh-keygen
+   一路回车
+   cd .ssh
+   ls    #  id-rsa  id-rsa.pub
+   vim id-rsa.pub


                   c 语言


1.  gcc -Wall **.c  # 严格检查代码     #  Wall中W 是大写！
2.  echo $?   #  运行之后，用此指令，若为0，正确，main 函数要把返回值返回到系统。
3.vim  编译    
(1)	+  gcc a.c  # 以 a.c 为例   
	+  ls
	+  ./a.out
(2)
	+  在vim里编译
	+  :w 
	+  :sh  # vim 命令行里
	+  cc a.c
	+  ./a.out
	+  ctrl D  #  回到vim里，光标位置不变，当代码多时能凸现出优点
	+  :u  # 回到上一次修改，ctrl D 再往回切
(3)     +  gcc -S a.c # 以a.c为例，
        +  ls  # 会出现 a.s
        +  vim a.s #  是汇编程序 
(4)     +  vim a.c 
        +  Ctrl+n   # it is used in INSERT mode
                      it will search current file add all included files
(5)     +  vim .vimrc # 对vim的设置
(6)     +  尽量用空格缩进，不用Tab；两者不能混用，如果混用，会造成格式混乱。

                            怎么写笔记

   上攒文件 (在笔记liuyu-note或liuyu-projects下)
(1)    +  git add a.c
       +  git commit -a -m " ***** "
       +  git push(第一次会有所不同)。
(2)   
       +  先 vim .gitconfig ,在最后一行写[core]
                                               editor = vim
       +  vim a.c (改一下，退出)
       +  git commit -a   #  可增加注释
       +  git push
                             怎么建工程
+    Dashboard
+    New Repository
+    填写第一行就行  Project Name 要与所建的文件名相同
                            怎么删除工程
+    Dashboard ——>***-Projects——>Admin
                            怎么删除工程里的文件
+    git rm a.c  ( 不跟踪)
+    git commit -a      （此步骤不能省）
+    git push


                          vim
+  /home/akaedu/.vim/snippets
+  vim c.snippets
+  举例         # added for dog
          snippet dog        记得type Tabe ,否则出现红字。
                I love dogs

  为了使命令简短(.bashrc)
+   /home/akaedu
+   vim .bashrc
+   举例        在最后一行输入 alias aaa='sudo apt-get install'
+   source .bashrc  #相当于把 .bashrc 里的全运行一遍
  vim 配置文件
+   vim .vimrc
    map <tab> :bn<cr>
    map jj <esc>
    map ,ss :set spell<cr>
    set hidden
	set autoindent  “回车时与上一行对齐”
	set expandtab  ''把 Tab 展开成空格“
	set tabstop=4   ”让Tab 占4个空格“
	set shiftwidth=4 “缩进4个空格，不是8个。”
    set dictionary=/usr/share/dict/words  "在.c文件里只检查注释"
  在vim 文件里怎么查找
+   /***
+   小写n.
                  怎么回到上一版

+   git checkout 版本号    #  就可以回到此版本
+   git checkout master    #  再切回来
+   git checkout 版本号 -b 定义一个新名
+   git branch
+   git checkout 新名      #  就可以回到此版本
+   git checkout -D 名     #  删除
+   现有master 分支，在做一个备份， git checkout -b tmp.

                  怎么把已经git push到网上的垃圾版本在改回去

+   git revert HEAD

+   如果没git push，用git throw就可以了。（可以查看vim .gitconfig）

+   卸载： sudo apt-get purge ***


                       where are you ?

+   which     #  which - locate a command 。只能定位系统上的命令  eg : which git ,which ls .
+   locat     #  locate - find files by name。 只能找到老文件，不能
找到新文件。
                 他在自己的数据库里查找，一段时间才更新    但在系统
                 上查找会比较慢。
+   find      #  find - search for files in a directory hierarchy >查找特定文件夹
                 里面的字符，find ***|grep ***. eg :  fint liuyu-projects|grep m .
+   ps aux |grep ***    #   eg : ps aux|grep firefox.
                             kill 进程号，退出。kill -9 进程号，强行退出。


(1)git clone https://github.com/happypeter/hen.git
   ~/hen/search/curse$ make
   ~/hen/search/curse$ sudo make install
(2) snipMate  在Google 中搜索——》下载——》当前文件下解压。
(3) gource
(4) new ***   # 同时打开两个，横
(5) vnew ***  # 同时打开两个，竖

       数据类型

+   最小的储存单位为位（bit），一个字节均为八位。
+   变量赋值，(1) 直接赋值，int a;
                              a = 5;
               (2)  声明语句中初始化变量，int a = 5;
               (3)  通过scanf()函数为变量赋值。
+   格式输出
    #include(stdio.h)
    int main (void)
    {
        int a = 100;
        printf("%d %o %x",a,a,a);
        printf("%d %#o %#x",a,a,a);
        return 0;
    }
    
    输出
        100 144 64
        100 0144 0x64  
+   整数的溢出

#include <stdio.h>
int main(int argc, const char *argv[])
{
    int i = 2147483647;
    unsigned int j = 4294967295;
    printf("%d %d %d\n",i,i+1,i+2);
    printf("%u %u %u\n",j,j+1,j+2);

    return 0;
}

  输出为
       
      2147483647  -2147483648  -2147483647
      4294967295  0  1

     当达到最大值时，它将溢出到起始点。整数i的起始点为-2147483648，无符号整形变量j的起始点为0.

#include <stdio.h>
int main(int argc, const char *argv[])
{

    unsigned int un = 3000000000;
    short end = 200;
    long big = 65537;
    long long verybig = 12345678908642;
    printf("un = %u add not %d\n",un,un);
    printf("edd = %hd add %d\n",end,end);
    printf("big = %ld add not %hd\n",big,big);
    printf("verybig = %lld add not %ld\n",verybig,verybig);

    return 0;
}

输出

un = 3000000000 add not -1294967296  //说明3000000000和-1294967296在内存中表示方法一样，un值太大，%d输出产生溢出。
edd = 200 add 200  // int类型被认为是计算机处理起来最有效的整数类型，使用%hd格式输出显示较长的整数被截为short类型值时的样子。
big = 65537 add not 1  //65537的二进制32位是00000000000000010000000000000001，%hd只显示后16位，即显示1。
verybig = 12345678908642 add not 1942899938  //%ld只显示了后32位的值。
      
            转义字符的输出

+   （1）使用ASCLL码值，char beep = 7；
+   （2）使用转义序列，char nerf = ‘\n’;
+   （3）使用十六进制表示字符常量。
+   （4）‘，“，\，的输出会照成混乱，可这样输出，\',\",\\.



+   在定义中，char类型使用1个字节的存储空间表示一个字符。
+   float，系统的浮点类型，至少能精确六位。



+   sizeof 返回的是字节。
+   int cost = 12.99；//浮点值转换为整数时，c简单的丢弃小数部分。
    float pi = 3.1415926536; //只能保证前六位是精确的，此式会损失部分精度。

+
    #include <stdio.h>
    #define PRAISE "liu yu"//主体是字符串必须用双引号括上，无论字符串中有没有空格
    int main(int argc, const char *argv[])
    {

          char name[20];
          char *p;
          p = name;
          printf("what is your name?\n");
          scanf("%s",name);//读入字符串时，遇空白字符（空格（blank），制表符（tab），换行符(newline)）停止读入,
     //   scanf("%s",p);   //第二个参数是数组只写数组名，不加地址符&，或指针变量，

          printf("%s\n%s\n",name,PRAISE);
        return 0;
    }



+   字符和字符串
    字符‘x’和字符串"x"不同，其中一个区别是‘x’属于基本类型（char），而“x”属于派生类型（char数组）。第二个区别是“x”实际上有两个字符（‘x’和空字符'\0'）组成。









